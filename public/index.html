<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>GRA Art Gallery</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #positionInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
        }

        #paintingInfo {
            background-color: rgba(255, 255, 255, 0.9);
            position: absolute;
            top: 60px;
            padding: 10px;
            right: 20px;
            font-family: Helvetica Neue Light;
            font-size: 18px;
        }

        #chatbox {
            background-color: rgba(255, 255, 255, 0.9);
            position: absolute;
            bottom: 10px;
            padding: 10px;
            left: 10px;
            font-family: Helvetica Neue Light;
            font-size: 18px;
        }

        .chatarea {
            background-color: rgba(255, 255, 255, 0.9);
            position: absolute;
            bottom: 85px;
            padding: 10px;
            overflow: auto;
            left: 10px;
            height: 200px;
            font-family: Helvetica Neue Light;
            font-size: 18px;
            width: 600px;
        }

        #tabs {
            position: absolute;
            bottom: 50px;
            padding: 10px;
            overflow: auto;
            left: 10px;
            height: 30px;
        }

        .tab-content {
            font-size: 28px;
        }

        #connectBtn {
            position: absolute;
            right: 30px;
            padding: 15px;
            background: #1D8482;
            color: #E0F1FF;
        }
    </style>
    </style>
</head>

<body>
    <!-- Add a button to switch between levels -->
    <button id="connectBtn" onclick="clickConnect()">Connect Wallet</button>
    <canvas id='canvas'></canvas>
    <div id='positionInfo'></div>
    <div id='paintingInfo'></div>

    <!-- <b>System: </b>Buy a <a target=_blank href=''>VIP NFT</a> to enter the 2nd level<br />-->
    <div id='chatarea' class='chatarea'><b>System:
        </b>Welcome to the GRA Art Gallery</div>
    <div id='chatarea_direct' class='chatarea' style="display:none"></div>
    <div id="tabs">
        <button class="tab-content" onclick="showTab()">World</button>
        <!-- <button class="tab-content" id="test" onclick="showTab(this.id)">0x23567</button>-->
    </div>
    <input id='chatbox' onchange='addMessage("Me",this.value);this.value=""'>
    <script src="three.min.js"></script>
    <script src="GLTFLoader.js"></script>

    <!-- change r98 accordingly https://rawcdn.githack.com/mrdoob/three.js/r98/examples/index.html -->
    <!-- <script src="PointerLockControls.js"></script> -->
    <!-- <script src="FirstPersonControls.js"></script> -->
    <!-- <script src="CSS3DRenderer.js"></script> looks terrible to embed this way -->
    <script>
        var playerPositions = [
            // { geoChoice: 0, colorChoice: 0, position: { x: -3, y: 0.1, z: -0.19 }, ry: -0.5 }
        ];
        let toAddr;
        let direct_messages = [];
        const playerMeshs = [];
        const fakePlayerMeshs = [];

        function addMessage(sender, msg) {
            if (sender == "Me") {
                sendMessage(msg);
            }
            // if DM to others, just wait for it to return
            if (!toAddr) {

                chatarea.innerHTML = "<b>" + sender + ": </b>" + msg + "<br/>" + chatarea.innerHTML;
            }
        }
        function showWhoIsOnline() {
            if (playerPositions.length == 0) return;
            msg = playerPositions.length + " other people online. Chat to them: ";
            for (player of playerPositions) {
                if (player.addr) { // only connected wallets
                    msg += "<a href='#' onclick='showTab(\"" + player.addr + "\");return false'>" + getNiceName(player.addr) + "</a> ";
                }
            }
            chatarea.innerHTML = "<b>System: </b>" + msg + "<br/>" + chatarea.innerHTML;

        }

        // Function to create a new tab for a direct message
        function createDirectMessageTab(otherAddr) {
            const tabs = document.getElementById('tabs');
            var found = false;
            for (i of tabs.children) {
                if (i.id == otherAddr) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                const tabContent = document.createElement('button');
                tabContent.classList.add('tab-content');
                tabContent.id = otherAddr;
                tabContent.textContent = getNiceName(otherAddr);
                tabContent.setAttribute("onclick", "showTab(this.id)");
                tabs.appendChild(tabContent);
            }
        }
        function showTab(otherAddr) {
            toAddr = otherAddr;
            if (otherAddr) {
                createDirectMessageTab(otherAddr.toLowerCase()); // create button if dont have
                chatarea_direct.innerHTML = "";
                for (msg of direct_messages) {

                    if (msg.to === accounts[0].toLowerCase() && msg.from === otherAddr.toLowerCase()) {
                        chatarea_direct.innerHTML = "<b>" + getNiceName(msg.from) + ": </b>" + msg.msg + "<br/>" + chatarea_direct.innerHTML;
                    } else if (msg.from === accounts[0].toLowerCase() && msg.to === otherAddr.toLowerCase()) {
                        chatarea_direct.innerHTML = "<b>Me: </b>" + msg.msg + "<br/>" + chatarea_direct.innerHTML;
                    }
                }
                chatarea.style.display = 'none';
                chatarea_direct.style.display = '';



                chatbox.placeholder = "Messaging " + otherAddr;
            } else {
                chatarea.style.display = '';
                chatarea_direct.style.display = 'none';
                chatbox.placeholder = "Messaging World";
            }

            chatbox.focus();
        }
        function renderPlayerPositions() {
            //clearExistingPlayers();
            fakePlayers = 3;

            old = false;
            if (old) {
                while (mesh = playerMeshs.pop()) {
                    scene.remove(mesh);
                }
                // renderer.renderLists.dispose();      
                for (player of playerPositions) {
                    //console.log(player.position);
                    playerMeshs.push(createCharacter_shape(player.geoChoice, player.colorChoice, player.position, player.ry));
                }
            } else {
                i = 0;
                for (player of playerPositions) {
                    //console.log(player.position);
                    otherCharacters[fakePlayers + i].position.set(player.position.x, player.position.y, player.position.z);
                    otherCharacters[fakePlayers + i].rotation.y = player.ry; //Math.PI + player.ry for mesh[0];
                    otherCharacters[fakePlayers + i].visible = true;
                    i++;
                    //console.log("rendering player" + otherCharacters[fakePlayers + i]);
                }
                i = fakePlayers + playerPositions.length;
                // hide extra characters (not fake or real)
                for (; i < otherCharacters.length; i++) {
                    otherCharacters[i].visible = false;
                }
            }
            //console.log(playerMeshs)
            // pretend for activity


            if (fakePlayerMeshs.length != 0) {
                for (playerMesh of fakePlayerMeshs) {
                    playerMesh.translateX(Math.random() > 0.8 ? 0.01 : -0.01);
                    playerMesh.translateZ(Math.random() > 0.8 ? 0.01 : -0.01);
                }
            } else {
                //fakePlayerMeshs.push(createCharacter_shape(1, Math.floor(Math.random() * randomColors.length), { x: -4 + Math.random() * 4, y: 0.1, z: -3 + Math.random() * 4 }, 0));
                //fakePlayerMeshs.push(createCharacter_shape(2, Math.floor(Math.random() * randomColors.length), { x: -4 + Math.random() * 4, y: 0.1, z: -3 + Math.random() * 4 }, 0));
                //fakePlayerMeshs.push(createCharacter_shape(1, Math.floor(Math.random() * randomColors.length), { x: -4 + Math.random() * 4, y: 0.1, z: -3 + Math.random() * 4 }, 0));
            }


            //renderPlayers();
        }

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("canvas") });
        renderer.setSize(window.innerWidth, window.innerHeight);

        /*
                var cssRenderer = new THREE.CSS3DRenderer();
                cssRenderer.setSize(window.innerWidth, window.innerHeight);
                cssRenderer.domElement.style.position = 'absolute';
                cssRenderer.domElement.style.top = 0;
                document.body.appendChild(cssRenderer.domElement);
                // Create a video div and object for the YouTube video
                var videoDiv = document.createElement('div');
                //videoDiv.innerHTML = '<iframe width="320" height="180" src="https://www.youtube.com/embed/BWxMuQre3R8?autoplay=1" frameborder="0" allowfullscreen></iframe>';
                videoDiv.innerHTML = '<iframe width="320" height="180" src="https://www.youtube.com/embed/BWxMuQre3R8?autoplay=1" frameborder="0" allowfullscreen></iframe>';
                var videoObject = new THREE.CSS3DObject(videoDiv);
                videoObject.scale.set(0.01, 0.01, 0.01);
                videoObject.position.set(0, 1.5, -10); // Adjust the video position
                scene.add(videoObject);
        */
        // Create a floor for the room
        const floorGeometry = new THREE.PlaneGeometry(15, 15);
        const floorTexture = new THREE.TextureLoader().load('Floor.jpg'); // Load your painting image
        const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture, side: THREE.DoubleSide });
        //const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = Math.PI / 2;

        scene.add(floor);
        const floorGeometry_2 = new THREE.PlaneGeometry(15, 7);
        const floor_2 = new THREE.Mesh(floorGeometry_2, floorMaterial); // use back floor geometry if dont want open L2 concept
        floor_2.rotation.x = Math.PI / 2;
        floor_2.position.set(0, 2.5, 0); // design 2 whereby open tall ceiling
        scene.add(floor_2);

        // Create a maze matrix (4 for auction painting center (will span 3 space width?), 3 for painting hung on wall on top, 2 for painting hung below wall,1s represent walls, 0s represent empty spaces)
        const mazeMatrix = [
            [1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 4, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1],
        ];
        const level2Matrix = [
            [1, 1, 1, 0, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 1],
        ];


        // Create maze walls based on the matrix
        const level_2_start = 2.5;
        const painting_zAdjust = 0.45;
        //const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x404040 });
        const wallTexture = new THREE.TextureLoader().load('Seamless wall white paint stucco plaster texture.jpg');
        const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture, side: THREE.DoubleSide });
        let auction_painting;
        let auction_painting_id = -1;
        paintings = [];
        const wallSize = 1; // Adjust the size of maze walls as needed
        //const paintingMaterial = new THREE.MeshBasicMaterial({ color: 0x004040, side: THREE.DoubleSide });
        for (let row = 0; row < mazeMatrix.length; row++) {
            for (let col = 0; col < mazeMatrix[row].length; col++) {
                if (mazeMatrix[row][col] === 1) {
                    const wallGeometry = new THREE.BoxGeometry(wallSize, level_2_start, wallSize);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(col - mazeMatrix.length / 2, level_2_start / 2 - 0.1, row - mazeMatrix[row].length / 2);
                    scene.add(wall);
                } else if (mazeMatrix[row][col] === 2 || mazeMatrix[row][col] === 3) {
                    const paintingGeometry = new THREE.PlaneGeometry(0.75, 0.75); // Adjust size as needed
                    const adjustType = (mazeMatrix[row][col] == 2 ? 1 : -1);
                    const paintingTexture = new THREE.TextureLoader().load('assets/' + (paintings.length + 1) + '.png'); // Load your painting image
                    const paintingMaterial = new THREE.MeshBasicMaterial({ map: paintingTexture, side: THREE.DoubleSide });

                    const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
                    paintings.push(painting);
                    painting.position.set(col - mazeMatrix.length / 2, 0.6, row - mazeMatrix[row].length / 2 + painting_zAdjust * adjustType); // Adjust position so it's in front of the wall
                    scene.add(painting);
                } else if (mazeMatrix[row][col] === 4) {
                    const paintingGeometry = new THREE.PlaneGeometry(2, 2); // Adjust size as needed
                    const adjustType = 1;
                    const paintingMaterial = new THREE.MeshBasicMaterial({ color: 0x00000, side: THREE.DoubleSide }); // black first until contract load?
                    auction_painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
                    auction_painting.position.set(col - mazeMatrix.length / 2, 1.4, row - mazeMatrix[row].length / 2 + painting_zAdjust * adjustType); // Adjust position so it's in front of the wall

                    scene.add(auction_painting);
                }
            }
        }
        function loadAuctionPainting(id) {

            auction_painting_id = id;
            if (auction_painting_id > 0) {
                model_auction.visible = true;
                const paintingTexture = new THREE.TextureLoader().load('assets/' + (auction_painting_id) + '.png'); // Load your painting image
                auction_painting.material = new THREE.MeshBasicMaterial({ map: paintingTexture, side: THREE.DoubleSide });
            } else {
                model_auction.visible = false;
                auction_painting.material = new THREE.MeshBasicMaterial({ color: 0x00000, side: THREE.DoubleSide });
            }
        }

        for (let row = 0; row < level2Matrix.length; row++) {
            for (let col = 0; col < level2Matrix[row].length; col++) {
                if (level2Matrix[row][col] === 1) {
                    const wallGeometry = new THREE.BoxGeometry(wallSize, level_2_start, wallSize);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(col - mazeMatrix.length / 2, level_2_start * 1.49, row - mazeMatrix[row].length / 2);
                    scene.add(wall);
                } else if (level2Matrix[row][col] === 2 || level2Matrix[row][col] === 3) {
                    const paintingGeometry = new THREE.PlaneGeometry(0.75, 0.75); // Adjust size as needed
                    const adjustType = (level2Matrix[row][col] == 2 ? 1 : -1);
                    const paintingTexture = new THREE.TextureLoader().load('assets/' + (paintings.length + 1) + '.png'); // Load your painting image
                    const paintingMaterial = new THREE.MeshBasicMaterial({ map: paintingTexture, side: THREE.DoubleSide });

                    const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
                    paintings.push(painting);
                    painting.position.set(col - level2Matrix.length / 2, level_2_start * 1.5 - 0.6, row - level2Matrix[row].length / 2 + painting_zAdjust * adjustType); // Adjust position so it's in front of the wall
                    scene.add(painting);
                }
            }
        }

        // Create a lift geometry
        const liftGeometry = new THREE.CylinderBufferGeometry(0.5, 0.5, 5, 32);
        const liftMaterial = new THREE.MeshBasicMaterial({ color: 0x0099ff, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const liftMesh = new THREE.Mesh(liftGeometry, liftMaterial);
        // Position the button in the scene
        liftMesh.position.set(-3.96, 0.05, 0.9);
        // Add the button to the scene
        scene.add(liftMesh);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;
        let moveY = false;
        let exitedLift = true;
        window.addEventListener('mousemove', (event) => {
            // Update the mouse coordinates when the mouse moves
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });
        window.addEventListener('click', () => {
            // Check for intersections with the cube when clicked
            raycaster.setFromCamera(mouse, camera);
            if (exitedLift && raycaster.intersectObjects([liftMesh]).length > 0) {
                //    moveWithLift();
            } else if (raycaster.intersectObjects([auction_painting]).length > 0) {
                if (auction_painting_id == 0) {
                    paintingInfo.innerHTML = "No Auction Currently. Please wait for next auction";
                } else {
                    paintingInfo.innerHTML =
                        "<a id='paintingName' target=_blank>Painting #" + auction_painting_id + "</a>"
                        + "<br/>Message Artist: <a href='#' id='creator'></a> "
                        + "<br/><iframe width=500 height=300 src=/public/index2.html></iframe>";

                    getPainting(auction_painting_id - 1).then((painting) => {
                        creator.setAttribute("onclick", "showTab('" + painting.creator + "');return false;");
                        creator.innerText = getNiceName(painting.creator);
                    });
                }
            } else if (raycaster.intersectObjects(paintings).length > 0) {
                const clickedPainting = raycaster.intersectObjects(paintings)[0].object;
                const clickedPaintingIndex = paintings.indexOf(clickedPainting);
                const id = clickedPaintingIndex + 1;
                //console.log(clickedPainting);
                paintingInfo.innerHTML =
                    "<a id='paintingName' target=_blank>Painting #" + id
                    + "</a>"
                    + "<br/>Owner: <a target='blank' id='ownerHref'></a>"
                    + "<br/>Message Artist: <a href='#' id='creator'></a> "
                    + "<br/><input type='button' id='" + (id) + "'>";

                getPainting(clickedPaintingIndex).then((painting) => { // 0-based
                    paintingName.href = "https://testnets.opensea.io/assets/mumbai/" + paintingAddress + "/" + id;
                    paintingName.textContent = "Painting #" + id + " (" + painting.name + ")";
                    ownerHref.href = "https://testnets.opensea.io/" + painting.owner;
                    button = document.querySelector("input[id='" + id + "']");
                    // message creator
                    creator.setAttribute("onclick", "showTab('" + painting.creator + "');return false;");
                    creator.innerText = getNiceName(painting.creator);

                    if (painting.owner === "0x0000000000000000000000000000000000000000") { // unowned
                        ownerHref.innerHTML = "Not Owned";
                        ownerHref.href = "";
                        button.value = "Mint";
                        button.onclick = function () { mintPainting(this.id) };
                    } else if (painting.owner === accounts[0]) { // owner is self, can list
                        ownerHref.innerHTML = "<b>You</b>";
                        button.onclick = function () {
                            var price = prompt("Price to List At");
                            if (price) {
                                //window.open("https://testnets.opensea.io/assets/mumbai/"+paintingAddress+"/"+id);
                                listPainting(id, price);
                            }
                        };

                        if (painting.list_price === "0" || painting.list_price == 0) { // not listed yet
                            button.value = "List for Sale";
                        } else {
                            button.value = "Listed for " + painting.list_price + ". Update List Price (0 to unlist)";
                        }


                    } else {
                        ownerHref.innerHTML = getNiceName(painting.owner);
                        if (painting.list_price === "0" || painting.list_price == 0) {
                            button.value = "Not For Sale (View On OpenSea)";
                            button.onclick = function () {
                                window.open("https://testnets.opensea.io/assets/mumbai/" + paintingAddress + "/" + id);
                            };
                        } else {

                            button.value = "Buy (Listed at " + painting.list_price + ")";
                            button.onclick = function () { buyPainting(this.id) };
                        }
                    }
                });

            }
        });


        function moveWithLift() {
            if (true) {
                moveY = true;
                exitedLift = false;
            } else {
                //alert("Buy a VIP NFT to enter the HL Zone");
            }
        }

        const randomColors = [0xff0000, 0x00ff00, 0x0000ff];
        const randomGeoChoices = [new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.SphereGeometry(0.2, 0.2, 0.2), new THREE.SphereGeometry(0.1, 0.2, 0.2)];
        function createCharacter_shape(geoChoice, colorChoice, pos, ry) {
            const characterGeometry = randomGeoChoices[geoChoice];
            const characterMaterial = new THREE.MeshBasicMaterial({ color: randomColors[colorChoice] });
            const character = new THREE.Mesh(characterGeometry, characterMaterial);
            character.position.set(pos.x, pos.y, pos.z); // Initial position of the character
            character.rotation.y = ry;
            // Create eyes (spheres) and position them relative to the character
            const eyeGeometry = new THREE.SphereGeometry(0.03, 32, 32);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            // Position the eyes relative to the character's head
            leftEye.position.set(-0.05, 0.15, 0.1); // Adjust these values as needed
            rightEye.position.set(0.05, 0.15, 0.1); // Adjust these values as needed
            // Add the eyes to the character
            character.add(leftEye);
            character.add(rightEye);

            scene.add(character);
            return character;
        }
        geoChoice = Math.floor(Math.random() * randomGeoChoices.length);
        colorChoice = Math.floor(Math.random() * randomColors.length);


        // avatar 2.0
        let walkAction;
        let mixer;
        let model, character;
        const glbLoader = new THREE.GLTFLoader();
        // https://www.mixamo.com/#/?page=2&type=Character
        // https://fabconvert.com/convert/fbx/to/glb
        glbLoader.load('assets/3.glb', (gltf) => {
            model = gltf.scene;

            // Scale and position the model
            model.scale.set(0.18, 0.18, 0.18);
            model.position.set(-2, 0, 0.61);

            // Load animations
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
                const action = mixer.clipAction(clip);
                if (!walkAction) { // just set if only 1
                    walkAction = action;
                    walkAction.setLoop(THREE.LoopRepeat); // Set the walk animation to loop
                } else if (clip.name === 'Walk') { // Change to the correct walk animation name if got
                    walkAction = action;
                    walkAction.setLoop(THREE.LoopRepeat); // Set the walk animation to loop
                }
                action.clampWhenFinished = false;
            });

            // Add the model to the scene
            scene.add(model);
            character = model;
            addMeText(0.3, 0.28, 1.9);
        });

        // cache so faster?
        //THREE.Cache.enabled = true;
        let otherCharacters = [];
        let otherActions = [];
        let otherMixers = [];
        function createCharacter(geoChoice, colorChoice, pos, ry) {
            extra = otherCharacter.clone();
            extra.position.set(pos.x, pos.y, pos.z);
            extra.rotation.y = ry;
            scene.add(extra);
            return extra;
        }

        character_choices = ["1","3"] //["0", "1"]// "3"];
        const glbLoader2 = new THREE.GLTFLoader();
        for (i = 0; i < 7; i++) {
            const choice = Math.floor(Math.random() * character_choices.length); //i % character_choices.length;//Math.floor(Math.random() * character_choices.length);
            const inFile = 'assets/' + character_choices[choice] + '.glb'
            console.log('choice is ' + choice);
            glbLoader2.load(inFile, (gltf) => {
                otherCharacter = gltf.scene;
                otherCharacters.push(otherCharacter);
                mixer = new THREE.AnimationMixer(otherCharacter);
                otherMixers.push(mixer);

                let otherAction;
                //otherAction = mixer.clipAction(gltf.animations[0]);
                for (clip of gltf.animations) {
                    action = mixer.clipAction(clip);
                    if (!otherAction) {
                        otherAction = action;
                    } else if (clip.name === 'Walk') { // Change to the correct walk animation name if got
                        otherAction = action;
                    }
                }
                otherAction.setLoop(THREE.LoopRepeat);
                otherActions.push(otherAction);
                otherCharacter.scale.set(0.3, 0.3, 0.3);
                scene.add(otherCharacter);

                if (otherCharacters.length == 7) {
                    for (i = 0; i < fakePlayers; i++) {
                        fakePlayerMeshs.push(otherCharacters[i]);
                        otherCharacters[i].position.set(-4 + Math.random() * 4, 0.1, -1 + Math.random() * 4);
                    }
                }
            });
        }



        const light = new THREE.AmbientLight(0xffffff, 1);
        scene.add(light);

        // load auctioner
        let action_auction;
        let mixer_auction;
        let model_auction;
        glbLoader.load('assets/auction.glb', (gltf) => {
            model_auction = gltf.scene;

            // Scale and position the model
            model_auction.scale.set(0.5, 0.5, 0.5);
            model_auction.position.set(-3.2, 0, 4)
            model_auction.rotation.y = -3.5

            // Create the rostrum geometry (You can customize the dimensions)
            const rostrumGeometry = new THREE.BoxGeometry(0.2, 2.3, 0.1);
            const rostrumMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            // Create the rostrum mesh by combining the geometry and material
            const rostrum = new THREE.Mesh(rostrumGeometry, rostrumMaterial);
            // Position the rostrum
            rostrum.position.set(0, 0, 0.5);
            model_auction.add(rostrum); 0x8B4513

            // Load animations
            mixer_auction = new THREE.AnimationMixer(model_auction);
            gltf.animations.forEach((clip) => {
                const action = mixer_auction.clipAction(clip);
                if (!action_auction) { // just set if only 1
                    action_auction = action;
                    action_auction.setLoop(THREE.LoopRepeat); // Set the walk animation to loop
                }

            });
            // add light as very dark
            var hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
            hemiLight.position.set(0, 10, 0);
            scene.add(hemiLight);

            // add light as very dark
            var hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
            hemiLight.position.set(0, 10, 0);
            scene.add(hemiLight);

            // Add the model to the scene
            model_auction.visible = false;
            scene.add(model_auction);

        });
        // load fake audience for auction (super lag for more )
        load_fake_audience = false;
        if (load_fake_audience) {
            for (i = 0; i < 1; i++) {
                let x = -1 - 0.6 * i; // declared so will be passed correctly
                glbLoader.load('assets/auction.glb', (gltf, i) => {
                    model_audience = gltf.scene;
                    // Scale and position the model
                    model_audience.scale.set(0.5, 0.5, 0.5);
                    model_audience.position.set(x, 0, 3.09)
                    //model_auction.rotation.y = 0
                    // Add the model to the scene
                    scene.add(model_audience);
                });
            }
        }



        // to fix
        function createCharacter2(geoChoice, colorChoice, pos, ry) {
            model.position.set(pos.x, pos.y, pos.z);
            model.rotation.y = ry;
            console.log("Character 2.0" + model);
            character = model;
        }
        //character = createCharacter2(geoChoice, colorChoice, { x: -2, y: 0.1, z: 0.61 });
        //createCharacter2(geoChoice, colorChoice, { x: -2, y: 0.1, z: 0.61 });
        // addMeText(0.03, 0.2) // old character
        let textLabel;
        function addMeText(fontsize, x, y) {
            // add "Me" text to character?
            const loader = new THREE.FontLoader();
            let font;
            loader.load('https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json',
                (loadedFont) => {
                    font = loadedFont;

                    // Create a 3D text label
                    const textGeometry = new THREE.TextGeometry('Me', {
                        font: font,
                        size: fontsize, // Text size
                        height: 0.005, // Extrusion depth
                    });
                    const textMaterial = new THREE.MeshBasicMaterial({ color: 0x404040 }); // Text color
                    textLabel = new THREE.Mesh(textGeometry, textMaterial);
                    textLabel.position.set(x, y, -1); // Adjust position as needed
                    textLabel.rotation.y = Math.PI;
                    //textLabel.rotation.z=Math.PI/2;
                    character.add(textLabel);
                });
        }
        // Initialize the camera for third-person view
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Animation parameters
        const movementSpeed = 0.03;
        var camY = 0.2;
        // Handle keyboard input for character movement
        const keys = {};
        let isWalking = false;
        const walkingKeys = ["w", "W", "a", "A", "s", "S", "d", "D", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
        document.addEventListener('keydown', (event) => {
            if (event.srcElement != chatbox) {
                keys[event.key] = true;
                if (walkingKeys.indexOf(event.key) >= 0) {
                    isWalking = true;
                }
            }
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
            // set isWalking false unless any of walkingKey is still up then true 
            if (walkingKeys.indexOf(event.key) >= 0) {
                isWalking = false;
                for (i of walkingKeys) {
                    if (keys[i]) {
                        isWalking = true;
                    }
                }
            }
        });


        /*
        controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());
        const pointerlockchange = () => {
            if (document.pointerLockElement === document.body) {
                controls.enabled = true;
                blocker.style.display = 'none';
            } else {
                controls.enabled = false;
                blocker.style.display = 'block';
                instructions.style.display = '';
            }
        };

        const pointerlockerror = () => {
            //instructions.style.display = '';
        };

        document.addEventListener('pointerlockchange', pointerlockchange, false);
        document.addEventListener('pointerlockerror', pointerlockerror, false);*/

        /*const controls = new THREE.FirstPersonControls(camera);
        controls.movementSpeed = 0.1;
        controls.lookSpeed = 0.05;*/

        // Animation loop
        let moveDown = false;
        let level2_y = 2.5 // 2.6 for createCharacter1
        let level1_y = 0.06  // 0.16 for createCharacter1
        function animate() {
            requestAnimationFrame(animate);

            if (!character) return;

            if (moveY) { // moving up/down lift
                character.position.z = 0.6; character.position.x = -3.96;
                if (character.position.y >= level2_y || moveDown) {
                    moveDown = true;
                    camY -= 2 * movementSpeed; character.translateY(-2 * movementSpeed);
                    if (character.position.y <= level1_y) {
                        moveY = false; moveDown = false;
                    }
                } else {
                    camY += 2 * movementSpeed; character.translateY(2 * movementSpeed);
                    if (character.position.y >= level2_y) { moveY = false; }
                }
            } else {
                // Move the character forward
                if (keys['ArrowUp'] || keys["w"] || keys["W"]) {
                    character.translateZ(movementSpeed);
                }
                if (keys['ArrowDown'] || keys["s"] || keys["S"]) {
                    character.translateZ(-movementSpeed);
                }
                if (keys['ArrowLeft'] || keys["a"] || keys["A"]) {
                    character.rotation.y += 0.05;
                }
                if (keys['ArrowRight'] || keys["d"] || keys["D"]) {
                    character.rotation.y -= 0.05;
                }
                if (keys['R'] || keys['r']) {
                    character.translateY(movementSpeed);
                    camY += movementSpeed;
                }
                if (keys['F'] || keys['f']) {
                    character.translateY(-movementSpeed);
                    camY -= movementSpeed;
                }
                // auto up/down
                const characterBox = new THREE.Box3().setFromObject(character);
                const liftBox = new THREE.Box3().setFromObject(liftMesh);
                if (characterBox.intersectsBox(liftBox)) {
                    if (exitedLift) { moveWithLift(); }
                } else {
                    exitedLift = true;
                }
            }

            if (isWalking) {
                walkAction.timeScale = 1.0; // Play walk animation
            } else {
                walkAction.timeScale = 0; // Pause walk animation
            }
            walkAction.play();
            mixer.update(0.01); // Update the animation

            for (i = 0; i < otherActions.length; i++) {
                otherActions[i].timeScale = 1.0;
                otherActions[i].play();
                otherMixers[i].update(0.01);
            }

            if (action_auction) {
                action_auction.timeScale = 1.0;
                action_auction.play();
                mixer_auction.update(0.01);
            }
            // Update the camera's position to follow the character
            const distance = 0.6; // Distance between character and camera
            const angle = character.rotation.y; // Angle of rotation
            const xOffset = distance * Math.sin(angle);
            firstPerson = true; // still off when turning
            if (firstPerson) {
                const zOffset = 0.01 * Math.cos(angle);
                // camera add to character then no need to readjust
                camera.position.y = 2;
                camera.rotation.y = -Math.PI;
                if (character) {
                    character.add(camera);
                }
                //character.add(camera);//camera.position.set(character.position.x - xOffset, camY + 0.09, character.position.z - zOffset);
                //camera.lookAt(character.position.x, character.position.y + 0.3, character.position.z);
                textLabel.visible = false;
            } else {
                const zOffset = 0.7 * Math.cos(angle);
                camera.position.set(character.position.x - xOffset, camY, character.position.z - zOffset);
                camera.lookAt(character.position);
                textLabel.visible = true;
            }
            renderer.render(scene, camera);
            //cssRenderer.render(scene, camera);
            //controls.update();
            positionInfo.innerText = (character.position.toArray() + ", ry: " + character.rotation.y);
        }
        animate();
        
    </script>
    <!-- somehow 4.1.1 will have revert error -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.9.0/web3.min.js"></script>
    <script defer src="web3.js"></script>
    <script src="indexHelper.js"></script>
</body>

</html>