<!--
    mobile can chat and move?
1st VIP to intro, 2nd screen non-Fan to buy Fan token
3rd Buy fixed price, 
4th start auction  -  CC, 
Chatting with others    

Add 2 person to block 2nd level
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=0">

    <title>GRA Art Gallery</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #positionInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
        }

        #paintingDetails {
            z-index: 10000;
            /* +1 from marquee */
            background-color: rgba(255, 255, 255, 0.9);
            position: absolute;
            top: 60px;
            padding: 10px;
            right: 20px;
            font-family: Helvetica Neue Light;
            font-size: 18px;
        }

        #paintingInfo>input,
        #live_auction>button {
            background-color: #DAA520;
            /* Use a gold or metallic color to evoke a sense of luxury. */
            color: #fff;
            /* White text for high contrast and readability. */
            border: none;
            border-radius: 5px;
            /* Rounded corners for a softer look. */
            font-size: 18px;
            /* A slightly larger font size for prominence. */
            text-transform: uppercase;
            /* Uppercase text for a formal touch. */
            letter-spacing: 1px;
            /* Spacing between letters for a refined appearance. */
            cursor: pointer;
            transition: background-color 0.3s ease;
            /* Smooth color transition on hover. */
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            /* Subtle shadow for depth. */
        }

        #chatbox {
            background-color: rgba(255, 255, 255, 0.9);
            /*margin: 10px;*/
            /* padding: 10px;*/
            font-family: Helvetica Neue Light;
            font-size: 18px;
        }

        #chatbox_div {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
        }

        .chatarea {
            position: absolute;
            bottom: 75px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            overflow: auto;
            height: 200px;
            font-family: Helvetica Neue Light;
            font-size: 18px;
            width: 300px;
        }

        #tabs {
            position: absolute;
            bottom: 30px;
            padding: 10px;
            overflow: auto;
            /*
            left: 10px;
            height: 30px;*/
        }

        .tab-content {
            font-size: 15px;
        }

        #connectDiv {
            position: absolute;
            right: 30px;
            padding: 15px;

        }

        #connectBtn,
        #changeNameBtn,
        #getVIPBtn {
            background: #1D8482;
            color: #E0F1FF;
        }

        #circle-overlay {
            position: absolute;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            left: calc(50% - 50px);
            top: calc(50% - 50px);
            /*bottom: 200px; must substract from this as now using midpoint*/
            pointer-events: none;
        }

        #container {
            position: relative;
            transition: opacity 2s;
        }

        #container canvas,
        #overlay {
            background: beige;
            position: absolute;
            align-items: center;
            justify-content: center;

        }

        /* emoji scrolling */
        .emoji-container {
            /*    display: flex;*/
        }

        .emoji {
            font-size: 18px;
            /*margin: 5px;*/
        }

        .marquee-container {
            z-index: 9999;
            position: absolute;
            width: 100%;
            /*overflow: hidden;*/
        }

        #marquee-row1 {
            top: 150px;
            /*overflow: hidden;*/
        }

        #marquee-row2 {
            top: 180px;
            /*overflow: hidden;*/
        }

        #marquee-row3 {
            top: 210px;
            /*overflow: hidden;*/
        }

        .marquee {
            font-size: 24px;
            white-space: nowrap;
            /*overflow: hidden;*/
            animation-duration: 10s;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            font-family: Helvetica Neue Light;

        }

        @keyframes marquee {
            0% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(-100%);
            }
        }
    </style>
    </style>
</head>

<body>
    <div id="container">
        <canvas id="loadingCanvas"></canvas>
        <div id="overlay" style="width:500px;">
            <!--<h4>Scan To Join The MetaVerse (Limited pax)</h4>-->
            <b>Step 1: Scan Left QR Code to login to Wifi</b>
            <br /><b>Step 2: Scan Right QR Code to open website</b>
            <br />
            <img align="left" width="150" src="public/assets/silver.png" />
            <img id='websiteQR' width="150" height="150" align="right" />
            <script>websiteQR.src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://${location.hostname}:5500/public/index.html`</script>

            <button id='explorerBtn' onclick="tryUnregisteredName()" style="width: 30%">Explorer Mode</button>
            <br /><b>OR</b>
            <br /><button onclick="loaded=true" style="width: 30%">Web3 Wallet User</button>
        </div>
    </div>
    <div id="circle-overlay"></div>
    <div id="connectDiv">
        <w3m-core-button></w3m-core-button>
        <button id="connectBtn" onclick="clickConnect()">Connect Wallet</button>
        <button id="changeNameBtn" style="display:none" onclick="changeName()">Change Name</button>
        <button id="getVIPBtn" style="display:none" onclick="getVIP()">üåüGet VIP</button>
    </div>
    <canvas id='canvas'></canvas>
    <div id='positionInfo'></div>
    <div id='paintingDetails'>
        <div id='paintingInfo'></div>
        <div id='auctionInfo'>
            <div id="bidFun"></div>
            <span id="live_auction" style='display:none'>
                <label for="bidAmount">Enter Bid: $</label>
                <input type="number" id="bidAmount" min="0" step="1">
                <br /><button onclick="placeBid()">Place Bid</button>
                <button onclick="placeBidHigher()">Place Higher Bid</button>
            </span>
            <span id="ended_auction" style='display:none'>
                <button onclick="payAuction()">Pay For Auction</button>
            </span>
            <div id="bidHistory"></div>
        </div>
    </div>

    <!-- <b>System: </b>Buy a <a target=_blank href=''>VIP NFT</a> to enter the 2nd level<br />-->
    <div id='chatarea' class='chatarea'><b>System:
        </b>Welcome to the GRA Art Gallery</div>
    <div id='chatarea_direct' class='chatarea' style="display:none"></div>
    <div id="tabs">
        <button class="tab-content" onclick="showTab()">World</button>
        <!-- <button class="tab-content" id="test" onclick="showTab(this.id)">0x23567</button>-->
    </div>
    <div id="marquee-row1" class="marquee-container"></div>
    <div id="marquee-row2" class="marquee-container"></div>
    <div id="marquee-row3" class="marquee-container"></div>

    <div id="chatbox_div">
        <input id='chatbox' onchange='addMessage("Me",this.value);this.value=""'>
        <div class="emoji-container">
            <button class="emoji" onclick="addMessage('Me', this.innerHTML);">üòä</button>
            <button class="emoji" onclick="addMessage('Me', this.innerHTML);">üéâ</button>
            <button class="emoji" onclick="addMessage('Me', this.innerHTML);">‚ù§Ô∏è</button>
            <!-- doesn't stop touchmove<script>
                for (b of document.querySelectorAll("button[class='emoji']")) {                    
                    b.addEventListener("click", function (e) {
                        e.preventDefault();
                 addMessage('Me', this.innerHTML);
                        e.stopPropagation();
                    })
                }</script>-->
            <!-- Add more emojis and their corresponding functions as needed -->
        </div>
    </div>
    <script src="three.min.js"></script>
    <script src="loading.js"></script>
    <script src="GLTFLoader.js"></script>

    <!-- change r98 accordingly https://rawcdn.githack.com/mrdoob/three.js/r98/examples/index.html -->
    <!-- <script src="PointerLockControls.js"></script> -->
    <!-- <script src="FirstPersonControls.js"></script> -->
    <!-- <script src="CSS3DRenderer.js"></script> looks terrible to embed this way -->
    <script>
        var isTouchScreen = 'ontouchstart' in window || navigator.msMaxTouchPoints;
        if (typeof (isTouchScreen) == 'undefined') {
            document.querySelector("#circle-overlay").style.display = 'none';
        } else { // hide for mobile
            document.querySelector("#positionInfo").style.display = 'none';
        }

        var playerPositions = [
            // { geoChoice: 0, colorChoice: 0, position: { x: -3, y: 0.1, z: -0.19 }, ry: -0.5 }
        ];
        let toAddr;
        let direct_messages = [];
        const playerMeshs = [];
        const fakePlayerMeshs = [];

        chatbox.addEventListener('keydown', function (event) {
            if (event.keyCode === 13) {
                addMessage("Me", this.value); this.value = "";
            }

        });
        function addMessage(sender, msg) {
            if (sender == "Me") {
                sendMessage(msg);
            }
            console.log(toAddr + "// addMessage " + sender + " msg " + msg);
            if ("üòäüéâ‚ù§Ô∏è".indexOf(msg) >= 0) {
                // process emoji 
                console.log("processing emoji from " + sender + ": " + msg)
                startMarquee(getNiceName(sender) + ": " + msg);
            }
            // if DM to others, just wait for it to return
            if (!toAddr) {
                if ("üòäüéâ‚ù§Ô∏è".indexOf(msg) >= 0) {
                    // process emoji
                    //console.log("processing emoji from " + sender + ": " + msg)
                    //startMarquee(getNiceName(sender) + ": " + msg);
                } else {
                    // use nicename since textarea too small for mobile users 
                    chatarea.innerHTML = "<b>" + getNiceName(sender) + ": </b>" + msg + "<br/>" + chatarea.innerHTML;
                }
            }
        }

        let lastWhoIsOnlineAnnouncement = null;
        function showWhoIsOnline() {
            if (playerPositions.length == 0) {
                lastWhoIsOnlineAnnouncement = null; // reset too
                return;
            }
            msg = playerPositions.length + " other people online. Chat to them: ";
            for (player of playerPositions) {
                if (player.addr) { // only connected wallets
                    msg += "<a href='#' onclick='showTab(\"" + player.addr + "\");return false'>" + getNiceName(player.addr) + "</a> ";
                }
            }

            if (msg != lastWhoIsOnlineAnnouncement) {
                lastWhoIsOnlineAnnouncement = msg; // prevent repeated msg
                chatarea.innerHTML = "<b>System: </b>" + msg + "<br/>" + chatarea.innerHTML;
            }

        }

        // Function to create a new tab for a direct message
        function createDirectMessageTab(otherAddr) {
            const tabs = document.getElementById('tabs');
            var found = false;
            for (i of tabs.children) {
                if (i.id == otherAddr) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                const tabContent = document.createElement('button');
                tabContent.classList.add('tab-content');
                tabContent.id = otherAddr;
                tabContent.textContent = getNiceName(otherAddr);
                tabContent.setAttribute("onclick", "showTab(this.id)");
                tabs.appendChild(tabContent);
            }
        }
        function showTab(otherAddr) {
            toAddr = otherAddr;
            if (otherAddr) {
                createDirectMessageTab(otherAddr.toLowerCase()); // create button if dont have
                chatarea_direct.innerHTML = "";

                document.querySelectorAll("[class='tab-content']").forEach((b) => { b.style.background = "" });
                document.querySelector("[id='" + otherAddr.toLowerCase() + "']").style.background = "lightblue";

                for (msg of direct_messages) {
                    if (isMe(msg.to) && msg.from === otherAddr.toLowerCase()) {
                        chatarea_direct.innerHTML = "<b>" + getNiceName(msg.from) + ": </b>" + msg.msg + "<br/>" + chatarea_direct.innerHTML;
                    } else if (isMe(msg.from) && msg.to === otherAddr.toLowerCase()) {
                        chatarea_direct.innerHTML = "<b>Me: </b>" + msg.msg + "<br/>" + chatarea_direct.innerHTML;
                    }
                }
                chatarea.style.display = 'none';
                chatarea_direct.style.display = '';

                chatbox.placeholder = "Messaging " + otherAddr;
            } else {
                // world
                document.querySelectorAll("[class='tab-content']").forEach((b) => { b.style.background = "" });
                document.querySelector("[class='tab-content']").style.background = "lightblue";
                chatarea.style.display = '';
                chatarea_direct.style.display = 'none';
                chatbox.placeholder = "Messaging World";
            }

            chatbox.focus();
        }
        function renderPlayerPositions() {
            //clearExistingPlayers();
            fakePlayers = 0;
            old = false; // old code of rendering live. too slow?
            if (old) {
                while (mesh = playerMeshs.pop()) {
                    scene.remove(mesh);
                }
                // renderer.renderLists.dispose();      
                for (player of playerPositions) {
                    //console.log(player.position);
                    playerMeshs.push(createCharacter_shape(player.geoChoice, player.colorChoice, player.position, player.ry));
                }
            } else {

                i = 0;
                for (player of playerPositions) {
                    cModel = otherCharacters[fakePlayers + i];
                    if (!cModel) {
                        console.log("wait for cModel to load for index " + i)
                        return;
                    }
                    //console.log(player.position);
                    cModel.position.set(player.position.x, player.position.y, player.position.z);
                    cModel.rotation.y = player.ry; //Math.PI + player.ry for mesh[0];
                    cModel.visible = true;
                    i++;
                    //console.log("rendering player" + otherCharacters[fakePlayers + i]);
                }
                i = fakePlayers + playerPositions.length;
                // hide extra characters (not fake or real)
                for (; i < otherCharacters.length; i++) {
                    otherCharacters[i].visible = false;
                }
            }
            //console.log(playerMeshs)
            // pretend for activity


            if (fakePlayerMeshs.length != 0) {
                for (playerMesh of fakePlayerMeshs) {
                    playerMesh.translateX(Math.random() > 0.8 ? 0.01 : -0.01);
                    playerMesh.translateZ(Math.random() > 0.8 ? 0.01 : -0.01);
                }
            } else {
                //fakePlayerMeshs.push(createCharacter_shape(1, Math.floor(Math.random() * randomColors.length), { x: -4 + Math.random() * 4, y: 0.1, z: -3 + Math.random() * 4 }, 0));
                //fakePlayerMeshs.push(createCharacter_shape(2, Math.floor(Math.random() * randomColors.length), { x: -4 + Math.random() * 4, y: 0.1, z: -3 + Math.random() * 4 }, 0));
                //fakePlayerMeshs.push(createCharacter_shape(1, Math.floor(Math.random() * randomColors.length), { x: -4 + Math.random() * 4, y: 0.1, z: -3 + Math.random() * 4 }, 0));
            }


            //renderPlayers();
        }

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ precision: 'mediump', canvas: document.getElementById("canvas") });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Create a floor for the room
        const floorGeometry = new THREE.PlaneGeometry(15, 15);
        const floorTexture = new THREE.TextureLoader().load('Floor2.jpg'); // Load your painting image
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.offset.set(0, 0);
        floorTexture.repeat.set(10, 10)

        const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture, side: THREE.DoubleSide });
        //const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = Math.PI / 2;

        scene.add(floor);
        const floorGeometry_2 = new THREE.PlaneGeometry(15, 7);
        const floor_2 = new THREE.Mesh(floorGeometry_2, floorMaterial); // use back floor geometry if dont want open L2 concept
        floor_2.rotation.x = Math.PI / 2;
        floor_2.position.set(0, 2.5, 0); // design 2 whereby open tall ceiling
        scene.add(floor_2);

        // Create a maze matrix (4 for auction painting center (will span 3 space width?), 3 for painting hung on wall on top, 2 for painting hung below wall,1s represent walls, 0s represent empty spaces)
        const mazeMatrix = [
            [1, 1, 1, 1, 1, 1, 1],
            [1, 3, 3, 3, 3, 3, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 4, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1],
        ];
        const level2Matrix = [
            [1, 1, 1, 1, 1, 1, 1],
            [1, 3, 3, 3, 3, 3, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 1],
            [1, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 1],
        ];


        // Create maze walls based on the matrix
        const level_2_start = 2.5;
        const painting_zAdjust = 0.45;
        //const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x404040 });
        let wallTexture = new THREE.TextureLoader().load('Seamless wall white paint stucco plaster texture.jpg');
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.offset.set(0, 0);
        wallTexture.repeat.set(1, 1); // 1 seem good enough
        const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture, side: THREE.DoubleSide });
        //let wallTexture2 = new THREE.TextureLoader().load("OfficeCeiling005_4K_Roughness.jpg");
        //const wallMaterial2 = new THREE.MeshBasicMaterial({ map: wallTexture2, side: THREE.DoubleSide });

        let auction_painting, frame_mesh, curtain;
        let auction_painting_id = -1;
        paintings = [];
        const wallSize = 1; // Adjust the size of maze walls as needed
        //const paintingMaterial = new THREE.MeshBasicMaterial({ color: 0x004040, side: THREE.DoubleSide });
        for (let row = 0; row < mazeMatrix.length; row++) {
            for (let col = 0; col < mazeMatrix[row].length; col++) {
                if (mazeMatrix[row][col] === 1) {
                    const wallGeometry = new THREE.BoxGeometry(wallSize, level_2_start, wallSize);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(col - mazeMatrix.length / 2, level_2_start / 2 - 0.1, row - mazeMatrix[row].length / 2);
                    scene.add(wall);
                } else if (mazeMatrix[row][col] === 2 || mazeMatrix[row][col] === 3) {
                    const paintingGeometry = new THREE.PlaneGeometry(0.75, 0.75); // Adjust size as needed
                    const adjustType = (mazeMatrix[row][col] == 2 ? 1 : -1);
                    const paintingTexture = new THREE.TextureLoader().load('assets/' + (paintings.length + 1) + '.png'); // Load your painting image
                    const paintingMaterial = new THREE.MeshBasicMaterial({ map: paintingTexture, side: THREE.DoubleSide });

                    const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
                    //paintings.splice(0, 0, painting);
                    paintings.push(painting);
                    painting.position.set(col - mazeMatrix.length / 2, 0.6, row - mazeMatrix[row].length / 2 + painting_zAdjust * adjustType); // Adjust position so it's in front of the wall
                    if (mazeMatrix[row][col] === 2) {
                        painting.rotation.y = -Math.PI  // flip as mirror
                    }

                    scene.add(painting);
                } else if (mazeMatrix[row][col] === 4) { // auction, assume 1st floor only
                    painting_size = 2; // auction size
                    const paintingGeometry = new THREE.PlaneGeometry(painting_size, painting_size); // Adjust size as needed
                    const adjustType = 1;
                    const paintingMaterial = new THREE.MeshBasicMaterial({ color: 0x00000, side: THREE.DoubleSide }); // black first until contract load?
                    auction_painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
                    auction_painting.position.set(col - mazeMatrix.length / 2, 1.4, row - mazeMatrix[row].length / 2 + painting_zAdjust * adjustType); // Adjust position so it's in front of the wall
                    auction_painting.rotation.y = -Math.PI;
                    scene.add(auction_painting);
                    // frame for painting
                    const frameGeometry = new THREE.PlaneGeometry(painting_size + 0.4, painting_size + 0.4);
                    const frameTexture = new THREE.TextureLoader().load('public/assets/frame.jpg');
                    const frameMaterial = new THREE.MeshBasicMaterial({ map: frameTexture, side: THREE.DoubleSide });
                    frame_mesh = new THREE.Mesh(frameGeometry, frameMaterial);
                    frame_mesh.position.set(auction_painting.position.x, auction_painting.position.y, auction_painting.position.z + 0.001);
                    frame_mesh.rotation.y = -Math.PI;
                    scene.add(frame_mesh);
                    // curtain instead of blackness
                    const curtainGeometry = new THREE.PlaneGeometry(painting_size, painting_size);
                    const curtainTexture = new THREE.TextureLoader().load('public/assets/curtain.avif');
                    const curtainMaterial = new THREE.MeshBasicMaterial({ map: curtainTexture, side: THREE.DoubleSide });
                    curtain = new THREE.Mesh(curtainGeometry, curtainMaterial);
                    curtain.rotation.y = -Math.PI;
                    curtain.position.set(auction_painting.position.x, auction_painting.position.y, auction_painting.position.z - 0.01);

                    scene.add(curtain);



                }
            }
        }
        function loadAuctionPainting(id) {
            auction_painting_id = id;
            if (auction_painting_id > 0) {
                model_auction.visible = true;
                curtain.visible = false;
                const paintingTexture = new THREE.TextureLoader().load('assets/' + (auction_painting_id) + '.png'); // Load your painting image
                auction_painting.material = new THREE.MeshBasicMaterial({ map: paintingTexture, side: THREE.DoubleSide });
            } else {
                model_auction.visible = false;
                curtain.visible = true;
                auction_painting.material = new THREE.MeshBasicMaterial({ color: 0x00000, side: THREE.DoubleSide });
            }
        }

        for (let row = 0; row < level2Matrix.length; row++) {
            for (let col = 0; col < level2Matrix[row].length; col++) {
                if (level2Matrix[row][col] === 1) {
                    const wallGeometry = new THREE.BoxGeometry(wallSize, level_2_start, wallSize);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(col - mazeMatrix.length / 2, level_2_start * 1.49, row - mazeMatrix[row].length / 2);
                    scene.add(wall);
                } else if (level2Matrix[row][col] === 2 || level2Matrix[row][col] === 3) {
                    const paintingGeometry = new THREE.PlaneGeometry(0.75, 0.75); // Adjust size as needed
                    const adjustType = (level2Matrix[row][col] == 2 ? 1 : -1);
                    const paintingTexture = new THREE.TextureLoader().load('assets/' + (paintings.length + 1) + '.png'); // Load your painting image
                    const paintingMaterial = new THREE.MeshBasicMaterial({ map: paintingTexture, side: THREE.DoubleSide });

                    const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
                    //paintings.splice(0, 0, painting);
                    paintings.push(painting);
                    painting.position.set(col - level2Matrix.length / 2, level_2_start * 1.5 - 0.6, row - level2Matrix[row].length / 2 + painting_zAdjust * adjustType); // Adjust position so it's in front of the wall
                    if (level2Matrix[row][col] === 2) {
                        painting.rotation.y = -Math.PI  // flip as mirror
                    }

                    scene.add(painting);
                }
            }
        }

        // Create a lift geometry
        const liftGeometry = new THREE.CylinderBufferGeometry(0.5, 0.5, 5, 32);
        const liftMaterial = new THREE.MeshBasicMaterial({ color: 0x0099ff, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        const liftMesh = new THREE.Mesh(liftGeometry, liftMaterial);
        // Position the button in the scene
        liftMesh.position.set(-3.96, 0.05, 0.9);
        // Add the button to the scene
        scene.add(liftMesh);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;
        let moveY = false;
        let exitedLift = true;
        window.addEventListener('mousemove', (event) => {
            // Update the mouse coordinates when the mouse moves
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });
        window.addEventListener('click', () => {
            // Check for intersections with the cube when clicked

            raycaster.setFromCamera(mouse, camera);
            if (exitedLift && raycaster.intersectObjects([liftMesh]).length > 0) {
                //    moveWithLift();
            } else if (raycaster.intersectObjects([auction_painting]).length > 0) {
                if (auction_painting_id <= 0) {
                    paintingInfo.innerHTML = "No Auction Currently. Please wait for next auction";
                    auctionInfo.style.display = 'none'; // only visible if auction
                } else {
                    paintingInfo.innerHTML =
                        "<a id='paintingName' target=_blank>Painting #" + auction_painting_id + "</a>"
                        + "<br/>Message Artist: <a href='#' id='creator'></a> ";
                    auctionInfo.style.display = '';
                    loadAuctionDiv();
                    //+ "<br/><iframe width=500 height=300 src=/public/index2.html></iframe>";

                    getPainting(auction_painting_id - 1).then((painting) => {
                        paintingName.textContent = "Painting #" + auction_painting_id + " (" + painting.name + ")";
                        creator.setAttribute("onclick", "showTab('" + painting.creator + "');return false;");
                        creator.innerText = getNiceName(painting.creator);
                    }).catch((ex) => {
                        console.log("Error in loading getPainting so fallback");
                        painting = web3Paintings[auction_painting_id - 1];
                        paintingName.textContent = "Painting #" + auction_painting_id + 1 + " (" + painting.name + ")";
                        creator.setAttribute("onclick", "showTab('" + painting.creator + "');return false;");
                        creator.innerText = getNiceName(painting.creator);
                    });



                }
            } else if (raycaster.intersectObjects(paintings).length > 0) {
                auctionInfo.style.display = 'none'; // only visible if auction
                const clickedPainting = raycaster.intersectObjects(paintings)[0].object;
                const clickedPaintingIndex = paintings.indexOf(clickedPainting);
                const id = clickedPaintingIndex + 1;
                //console.log(clickedPainting);
                if (unregistered_name) {

                    console.log("for non-web3 users");
                    info = "";
                    painting = web3Paintings[clickedPaintingIndex];
                    if (painting.owner == "0x0000000000000000000000000000000000000000") {
                        info = "Painting #" + id + " (" + painting.name + ")<br/>Not Owned";
                    } else {
                        info = "<a target=_blank href='https://testnets.opensea.io/assets/mumbai/" + paintingAddress + "/" + id
                            + "'>Painting #" + id
                            + " (" + painting.name + ")</a>"
                            + "<br/>Owner: <a href='#' onclick=\"showTab('" + painting.owner + "');return false;\">" + getNiceName(painting.owner) + "</a>"
                    }

                    paintingInfo.innerHTML =
                        info
                        + "<br/>Message Artist: <a href='#' onclick=\"showTab('" + painting.creator + "');return false;\">" + getNiceName(painting.creator) + "</a>"

                } else {
                    paintingInfo.innerHTML =
                        "<a id='paintingName' target=_blank>Painting #" + id
                        + "</a>"
                        + "<br/>Owner: <a target='blank' id='ownerHref'></a>"
                        + "<br/>Message Artist: <a href='#' id='creator'></a> "
                        + "<br/><input type='button' id='" + (id) + "'>";


                    getPainting(clickedPaintingIndex).then((painting) => { // 0-based
                        paintingName.href = "https://testnets.opensea.io/assets/mumbai/" + paintingAddress + "/" + id;
                        paintingName.textContent = "Painting #" + id + " (" + painting.name + ")";
                        ownerHref.setAttribute("onclick", "showTab('" + painting.owner + "');return false;"); //.href = "https://testnets.opensea.io/" + painting.owner;
                        button = document.querySelector("input[id='" + id + "']");
                        // message creator
                        creator.setAttribute("onclick", "showTab('" + painting.creator + "');return false;");
                        creator.innerText = getNiceName(painting.creator);

                        if (painting.owner === "0x0000000000000000000000000000000000000000") { // unowned
                            paintingName.href = "#"; // since not minted yet

                            ownerHref.innerHTML = "Not Owned";
                            ownerHref.href = "#";
                            button.value = "Mint";
                            button.onclick = function () { mintPainting(this.id) };
                        } else if (painting.owner === accounts[0]) { // owner is self, can list
                            ownerHref.innerHTML = "<b>You</b>";
                            button.onclick = function () {
                                var price = prompt("Price to List At");
                                if (price) {
                                    //window.open("https://testnets.opensea.io/assets/mumbai/"+paintingAddress+"/"+id);
                                    listPainting(id, price);
                                }
                            };

                            if (painting.list_price === "0" || painting.list_price == 0) { // not listed yet
                                button.value = "List for Sale";
                            } else if (painting.list_price === "-1" || painting.list_price == -1) { // in auction
                                button.value = "Painting In Auction"; // can update but not mentioned
                            } else {
                                button.value = "Listed for " + painting.list_price; // + ". Update List Price (0 to unlist)";
                            }


                        } else {
                            ownerHref.innerHTML = getNiceName(painting.owner);
                            if (painting.list_price === "0" || painting.list_price == 0) {
                                button.value = "Not For Sale (View On OpenSea)";
                                button.onclick = function () {
                                    window.open("https://testnets.opensea.io/assets/mumbai/" + paintingAddress + "/" + id);
                                };
                            } else {

                                button.value = "Buy (Listed at " + painting.list_price + ")";
                                button.onclick = function () { buyPainting(this.id) };
                            }
                        }
                    });
                }
            }
        });

        let showBuyVIPAlready = false;
        function moveWithLift() {
            if (accounts && accounts.length > 0) {
                vipContract.methods.balanceOf(accounts[0], 1).call().then(function (result) {
                    console.log("result: " + result);
                    if (result > 0) { // own at least 1
                        moveY = true;
                        exitedLift = false;
                    } else if (!showBuyVIPAlready) {
                        showBuyVIPAlready = true;
                        //character.position.set(-2.9, 0, 0.94);
                        //character.rotation.y = -1.7;
                        m = startMarquee("System: Buy a Fan Token to enter VIP area at level 2");
                        m.addEventListener('animationend', () => {
                            showBuyVIPAlready = false;
                        });
                        chatarea.innerHTML = "<b>System: </b> <a href='#' onclick='alert(\"trigger Mint NFT\")'>Buy a Fan Token</a> to enter the VIP area at level 2<br/>"
                            + chatarea.innerHTML;

                    }
                });
            } else if (!showBuyVIPAlready) {
                showBuyVIPAlready = true;
                // unregistered user cannot go up too
                //character.position.set(-2.9, 0, 0.94);
                //character.rotation.y = -1.7;
                m = startMarquee("System: Buy a Fan Token to enter level 2.");
                m.addEventListener('animationend', () => {
                    showBuyVIPAlready = false;
                });
                chatarea.innerHTML = "<b>System: </b> Buy a Fan Token to enter level 2. Login with your wallet and get one now<br/>"
                    + chatarea.innerHTML;

            }
        }

        const randomColors = [0xff0000, 0x00ff00, 0x0000ff];
        const randomGeoChoices = [new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.SphereGeometry(0.2, 0.2, 0.2), new THREE.SphereGeometry(0.1, 0.2, 0.2)];
        function createCharacter_shape(geoChoice, colorChoice, pos, ry) {
            const characterGeometry = randomGeoChoices[geoChoice];
            const characterMaterial = new THREE.MeshBasicMaterial({ color: randomColors[colorChoice] });
            const character = new THREE.Mesh(characterGeometry, characterMaterial);
            character.position.set(pos.x, pos.y, pos.z); // Initial position of the character
            character.rotation.y = ry;
            // Create eyes (spheres) and position them relative to the character
            const eyeGeometry = new THREE.SphereGeometry(0.03, 32, 32);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            // Position the eyes relative to the character's head
            leftEye.position.set(-0.05, 0.15, 0.1); // Adjust these values as needed
            rightEye.position.set(0.05, 0.15, 0.1); // Adjust these values as needed
            // Add the eyes to the character
            character.add(leftEye);
            character.add(rightEye);

            scene.add(character);
            return character;
        }
        geoChoice = Math.floor(Math.random() * randomGeoChoices.length);
        colorChoice = Math.floor(Math.random() * randomColors.length);


        // avatar 2.0
        let walkAction;
        let mixer;
        let model, character;
        const glbLoader = new THREE.GLTFLoader();
        // https://www.mixamo.com/#/?page=2&type=Character
        // https://fabconvert.com/convert/fbx/to/glb
        glbLoader.load('assets/3.glb', (gltf) => {
            model = gltf.scene;

            // Scale and position the model
            model.scale.set(0.18, 0.18, 0.18);
            model.position.set(-2, 0, 0.61);

            // Load animations
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
                const action = mixer.clipAction(clip);
                if (!walkAction) { // just set if only 1
                    walkAction = action;
                    walkAction.setLoop(THREE.LoopRepeat); // Set the walk animation to loop
                } else if (clip.name === 'Walk') { // Change to the correct walk animation name if got
                    walkAction = action;
                    walkAction.setLoop(THREE.LoopRepeat); // Set the walk animation to loop
                }
                action.clampWhenFinished = false;
            });

            // Add the model to the scene
            scene.add(model);
            character = model;
            addMeText(0.3, 0.28, 1.9);
        });

        // cache so faster?
        //THREE.Cache.enabled = true;
        let otherCharacters = [];
        let otherActions = [];
        let otherMixers = [];
        function createCharacter(geoChoice, colorChoice, pos, ry) {
            extra = otherCharacter.clone();
            extra.position.set(pos.x, pos.y, pos.z);
            extra.rotation.y = ry;
            scene.add(extra);
            return extra;
        }

        const light = new THREE.AmbientLight(0xffffff, 2);
        scene.add(light);

        // load auctioner
        let action_auction;
        let mixer_auction;
        let model_auction;
        glbLoader.load('assets/auction.glb', (gltf) => {
            model_auction = gltf.scene;

            // Scale and position the model
            model_auction.scale.set(0.5, 0.5, 0.5);
            model_auction.position.set(-3.2, 0, 4)
            model_auction.rotation.y = -3.5

            // Create the rostrum geometry (You can customize the dimensions)
            const rostrumGeometry = new THREE.BoxGeometry(0.2, 2.3, 0.1);
            const rostrumMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            // Create the rostrum mesh by combining the geometry and material
            const rostrum = new THREE.Mesh(rostrumGeometry, rostrumMaterial);
            // Position the rostrum
            rostrum.position.set(0, 0, 0.5);
            model_auction.add(rostrum); //0x8B4513

            // Load animations
            mixer_auction = new THREE.AnimationMixer(model_auction);
            gltf.animations.forEach((clip) => {
                const action = mixer_auction.clipAction(clip);
                if (!action_auction) { // just set if only 1
                    action_auction = action;
                    action_auction.setLoop(THREE.LoopRepeat); // Set the walk animation to loop
                }

            });
            // Add the model to the scene if auction there            
            model_auction.visible = auction_painting_id > 0; // false;
            if (auction_painting_id > 0) {
                loadAuctionPainting(auction_painting_id);
            }

            scene.add(model_auction);
        });
        // load fake audience for auction (super lag for more )
        load_fake_audience = false;
        if (load_fake_audience) {
            for (i = 0; i < 1; i++) {
                let x = -1 - 0.6 * i; // declared so will be passed correctly
                glbLoader.load('assets/auction.glb', (gltf, i) => {
                    model_audience = gltf.scene;
                    // Scale and position the model
                    model_audience.scale.set(0.5, 0.5, 0.5);
                    model_audience.position.set(x, 0, 3.09)
                    //model_auction.rotation.y = 0
                    // Add the model to the scene
                    scene.add(model_audience);
                });
            }
        }

        let model_bouncer;
        glbLoader.load('assets/bouncer.glb', (gltf) => {
            model_bouncer = gltf.scene;

            // Scale and position the model
            model_bouncer.scale.set(0.4, 0.4, 0.4);
            model_bouncer.position.set(-3.6, 0, 0.096)
            model_bouncer.rotation.y = 1.15

            // Load animations
            m = new THREE.AnimationMixer(model_bouncer);
            otherMixers.push(m);
            otherActions.push(m.clipAction(gltf.animations[0]));
            scene.add(model_bouncer);
        });
        // dinosaur
        glbLoader.load('assets/dino.glb', (gltf) => {
            model_dino = gltf.scene;

            // Scale and position the model
            model_dino.scale.set(0.5, 0.5, 0.5);
            model_dino.position.set(3.4, 0, -0.88)
            model_dino.rotation.y = 0.29

            // Load animations
            m = new THREE.AnimationMixer(model_dino);
            otherMixers.push(m);
            otherActions.push(m.clipAction(gltf.animations[1]));

            /*
            // load a sound and set it as the PositionalAudio object's buffer
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load('public/assets/trex.wav', function (buffer) {
                const sound = new THREE.PositionalAudio(listener);
                sound.setBuffer(buffer);
                sound.setLoop(true);
                sound.setRefDistance(50);
                //sound.setVolume( 0.5 );

                sound.play();
                
                model_dino.add(sound);
            });*/
            scene.add(model_dino);
        });
        let model_spaceman;
        glbLoader.load('assets/spaceman.glb', (gltf) => {
            model_spaceman = gltf.scene;

            // Scale and position the model
            model_spaceman.scale.set(0.25, 0.25, 0.25);

            model_spaceman.position.set(3.2, 0.7, 2, 3)
            model_spaceman.rotation.y = 4.4

            // Load animations
            m = new THREE.AnimationMixer(model_spaceman);
            otherMixers.push(m);
            otherActions.push(m.clipAction(gltf.animations[2]));

            scene.add(model_spaceman);
        });

        character_choices = ["1", "1", "4", "4", "5", "6"] // "0" is facing wrongly, "2" too tall, "3" is too dark ["0", "1"]// "3"];
        // 1 is lady, 4 is old man, 5 is suit girl, 6 is child
        //const glbLoader2 = new THREE.GLTFLoader();
        const MAX_CHARACTERS = 15;
        for (i = 0; i < MAX_CHARACTERS; i++) {
            const choice = Math.floor(Math.random() * character_choices.length); //i % character_choices.length;//Math.floor(Math.random() * character_choices.length);
            const inFile = 'assets/' + character_choices[choice] + '.glb'
            //console.log('choice is ' + choice);
            glbLoader.load(inFile, (gltf) => {
                otherCharacter = gltf.scene;
                otherCharacters.push(otherCharacter);
                mixer = new THREE.AnimationMixer(otherCharacter);
                otherMixers.push(mixer);

                let otherAction;
                //otherAction = mixer.clipAction(gltf.animations[0]);
                for (clip of gltf.animations) {
                    action = mixer.clipAction(clip);
                    if (!otherAction) {
                        otherAction = action;
                    } else if (clip.name === 'Walk') { // Change to the correct walk animation name if got
                        otherAction = action;
                    }
                }
                otherAction.setLoop(THREE.LoopRepeat);
                otherActions.push(otherAction);
                otherCharacter.scale.set(0.3, 0.3, 0.3);
                scene.add(otherCharacter);

                if (otherCharacters.length == MAX_CHARACTERS) {
                    for (i = 0; i < fakePlayers; i++) {
                        fakePlayerMeshs.push(otherCharacters[i]);
                        otherCharacters[i].position.set(-4 + Math.random() * 4, 0.1, -1 + Math.random() * 4);
                    }
                }
            });
        }
        character_choices = ["1", "4", "5", "6"] // "0" is facing wrongly, "2" too tall, "3" is too dark ["0", "1"]// "3"];
        //glbLoader2 = new THREE.GLTFLoader();
        for (i = 0; i < 7; i++) {
            const choice = Math.floor(Math.random() * character_choices.length); //i % character_choices.length;//Math.floor(Math.random() * character_choices.length);
            const inFile = 'assets/' + character_choices[choice] + '.glb'
            //console.log('choice is ' + choice);
            glbLoader.load(inFile, (gltf) => {
                otherCharacter = gltf.scene;
                otherCharacters.push(otherCharacter);
                mixer = new THREE.AnimationMixer(otherCharacter);
                otherMixers.push(mixer);

                let otherAction;
                //otherAction = mixer.clipAction(gltf.animations[0]);
                for (clip of gltf.animations) {
                    action = mixer.clipAction(clip);
                    if (!otherAction) {
                        otherAction = action;
                    } else if (clip.name === 'Walk') { // Change to the correct walk animation name if got
                        otherAction = action;
                    }
                }
                otherAction.setLoop(THREE.LoopRepeat);
                otherActions.push(otherAction);
                otherCharacter.scale.set(0.3, 0.3, 0.3);
                scene.add(otherCharacter);

                if (otherCharacters.length == 7) {
                    for (i = 0; i < fakePlayers; i++) {
                        fakePlayerMeshs.push(otherCharacters[i]);
                        otherCharacters[i].position.set(-4 + Math.random() * 4, 0.1, -1 + Math.random() * 4);
                    }
                }
            });
        }

        // to fix
        function createCharacter2(geoChoice, colorChoice, pos, ry) {
            model.position.set(pos.x, pos.y, pos.z);
            model.rotation.y = ry;
            console.log("Character 2.0" + model);
            character = model;
        }
        //character = createCharacter2(geoChoice, colorChoice, { x: -2, y: 0.1, z: 0.61 });
        //createCharacter2(geoChoice, colorChoice, { x: -2, y: 0.1, z: 0.61 });
        // addMeText(0.03, 0.2) // old character
        let textLabel;
        function addMeText(fontsize, x, y) {
            // add "Me" text to character?
            const loader = new THREE.FontLoader();
            let font;
            loader.load('https://unpkg.com/three@0.77.0/examples/fonts/helvetiker_regular.typeface.json',
                (loadedFont) => {
                    font = loadedFont;

                    // Create a 3D text label
                    const textGeometry = new THREE.TextGeometry('Me', {
                        font: font,
                        size: fontsize, // Text size
                        height: 0.005, // Extrusion depth
                    });
                    const textMaterial = new THREE.MeshBasicMaterial({ color: 0x404040 }); // Text color
                    textLabel = new THREE.Mesh(textGeometry, textMaterial);
                    textLabel.position.set(x, y, -1); // Adjust position as needed
                    textLabel.rotation.y = Math.PI;
                    //textLabel.rotation.z=Math.PI/2;
                    character.add(textLabel);
                });
        }
        // Initialize the camera for third-person view
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // trex
        //const listener = new THREE.AudioListener();
        //camera.add(listener);

        // Animation parameters
        const movementSpeed = 0.03;
        var camY = 0.2;
        // Handle keyboard input for character movement
        const keys = {};
        let isWalking = false;
        const walkingKeys = ["w", "W", "a", "A", "s", "S", "d", "D", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
        document.addEventListener('keydown', (event) => {
            if (event.srcElement != chatbox) {
                keys[event.key] = true;
                if (walkingKeys.indexOf(event.key) >= 0) {
                    isWalking = true;
                }
            }
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
            // set isWalking false unless any of walkingKey is still up then true 
            if (walkingKeys.indexOf(event.key) >= 0) {
                isWalking = false;
                for (i of walkingKeys) {
                    if (keys[i]) {
                        isWalking = true;
                    }
                }
            }
        });

        // emoji marquee
        let currentMarqueeRow = 1;
        function startMarquee(emoji) {
            const marquee = document.createElement('div');
            marquee.classList.add('marquee');
            marquee.classList.add('marquee-container');
            marquee.textContent = emoji;
            marquee.id = 'marquee-row' + currentMarqueeRow;
            document.body.appendChild(marquee);
            //document.querySelector(`#marquee - row${ currentMarqueeRow }`).appendChild(marquee);

            marquee.style.animation = 'marquee 10s linear ';
            marquee.addEventListener('animationend', () => {
                marquee.remove();
            });
            currentMarqueeRow = (currentMarqueeRow % 3) + 1;

            return marquee; // return so that can allow VIP message again
        }

        let rotateLeft, rotateRight, moveForward, moveBackward;
        const maxMovement = 0.001;  // Maximum movement distance from the center of the circle
        const maxRotation = 0.001;
        // Attach touch event handlers
        document.addEventListener('touchstart', onTouchStart);
        document.addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);
        function onTouchStart(event) {
            //console.log("ontouch" + event)
            //console.log(event.target);
            //  event.preventDefault();
            if (event.target && (event.target.tagName.toLowerCase() == "button"
                || event.target.tagName.toLowerCase() == "input")) {
                // don't move when click on button
                return;
            }
            const touch = event.touches[0];

            // Calculate touch movement distance from the center of the circle
            const deltaX = touch.clientX - window.innerWidth / 2;
            const deltaY = touch.clientY - window.innerHeight / 2;
            const threshold = 80;
            //console.log(deltaY)
            if (deltaY < -threshold) {
                moveForward = true;
            } else if (deltaY > threshold) {
                moveBackward = true;
            } else if (deltaX < 0) {
                rotateLeft = true;
            } else {
                rotateRight = true;
            }
        }

        function onTouchEnd(event) {
            rotateLeft = false;
            rotateRight = false;
            moveForward = false;
            moveBackward = false;
        }
        function onTouchMove(event) {
            rotateLeft = false;
            rotateRight = false;
            moveForward = false;
            moveBackward = false;
        }
        /*function onTouchMove(event) {
            //event.preventDefault();
            const touch = event.touches[0];
 
            // Calculate touch movement distance from the center of the circle
            const deltaX = touch.clientX - window.innerWidth / 2;
            const deltaY = touch.clientY - window.innerHeight / 2;
            const threshold = 100;
            //console.log(deltaY)
            if (deltaY < -threshold) {
                moveForward = true;
            } else if (deltaY > threshold) {
                moveBackward = true;
            } else if (deltaX < 0) {
                rotateLeft = true;
            } else {
                rotateRight = true;
            }
            // Update camera position based on touch position
            //character.position.x += movementXRatio * maxMovement;
            //const rotationY = Math.max(maxRotation, (deltaX / maxMovement) * Math.PI);  // Rotate up to PI radians (180 degrees)
            //character.rotation.y += 0.01;//rotationY;
            //character.position.z -= movementYRatio * maxMovement;
            //console.log(maxMovement)
            //console.log(movementYRatio);
        }*/
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }


        // Animation loop
        let moveDown = false;
        let level2_y = 2.5 // 2.6 for createCharacter1
        let level1_y = 0.06  // 0.16 for createCharacter1
        function animate() {
            requestAnimationFrame(animate);
            if (!loaded) {
                return;
            }
            if (!character) return;

            if (moveY) { // moving up/down lift
                character.position.z = 0.6; character.position.x = -3.96;
                if (character.position.y >= level2_y || moveDown) {
                    moveDown = true;
                    camY -= 2 * movementSpeed; character.translateY(-2 * movementSpeed);
                    if (character.position.y <= level1_y) {
                        moveY = false; moveDown = false;
                    }
                } else {
                    camY += 2 * movementSpeed; character.translateY(2 * movementSpeed);
                    if (character.position.y >= level2_y) { moveY = false; }
                }
            } else {
                // Move the character forward
                if (keys['ArrowUp'] || keys["w"] || keys["W"] || moveForward) {
                    character.translateZ(movementSpeed);
                }
                if (keys['ArrowDown'] || keys["s"] || keys["S"] || moveBackward) {
                    character.translateZ(-movementSpeed);
                }
                if (keys['ArrowLeft'] || keys["a"] || keys["A"] || rotateLeft) {
                    character.rotation.y += 0.05;
                }
                if (keys['ArrowRight'] || keys["d"] || keys["D"] || rotateRight) {
                    character.rotation.y -= 0.05;
                }
                if (keys['R'] || keys['r']) {
                    character.translateY(movementSpeed);
                    camY += movementSpeed;
                }
                if (keys['F'] || keys['f']) {
                    character.translateY(-movementSpeed);
                    camY -= movementSpeed;
                }
                // auto up/down
                const characterBox = new THREE.Box3().setFromObject(character);
                const liftBox = new THREE.Box3().setFromObject(liftMesh);
                if (characterBox.intersectsBox(liftBox)) {
                    if (exitedLift) { moveWithLift(); }
                } else {
                    exitedLift = true;
                }
            }

            if (isWalking) {
                walkAction.timeScale = 1.0; // Play walk animation
            } else {
                walkAction.timeScale = 0; // Pause walk animation
            }
            walkAction.play();
            mixer.update(0.01); // Update the animation

            for (i = 0; i < otherActions.length; i++) {
                otherActions[i].timeScale = 1.0;
                otherActions[i].play();
                otherMixers[i].update(0.01);
            }

            if (action_auction) {
                action_auction.timeScale = 1.0;
                action_auction.play();
                mixer_auction.update(0.01);
            }
            // Update the camera's position to follow the character
            const distance = 0.6; // Distance between character and camera
            const angle = character.rotation.y; // Angle of rotation
            const xOffset = distance * Math.sin(angle);
            firstPerson = true; // still off when turning
            if (firstPerson) {
                const zOffset = 0.01 * Math.cos(angle);
                // camera add to character then no need to readjust
                camera.position.y = 2;
                camera.rotation.y = -Math.PI;
                if (character) {
                    character.add(camera);
                }
                //character.add(camera);//camera.position.set(character.position.x - xOffset, camY + 0.09, character.position.z - zOffset);
                //camera.lookAt(character.position.x, character.position.y + 0.3, character.position.z);
                textLabel.visible = false;
            } else {
                const zOffset = 0.7 * Math.cos(angle);
                camera.position.set(character.position.x - xOffset, camY, character.position.z - zOffset);
                camera.lookAt(character.position);
                textLabel.visible = true;
            }
            //outer space
            earth.rotation.y += 0.01// .0009;
            theta += dTheta;
            moon.position.x = r * Math.cos(theta);
            moon.position.z = r * Math.sin(theta);

            if (model_spaceman) {
                model_spaceman.rotation.x += 0.01;
            }
            renderer.render(scene, camera);
            //cssRenderer.render(scene, camera);
            //controls.update();
            positionInfo.innerText = (character.position.toArray() + ", ry: " + character.rotation.y);
        }
        animate();

    </script>
    <!-- somehow 4.1.1 will have revert error -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.9.0/web3.min.js"></script>
    <script src="web3.js"></script>
    <script src="auction.js"></script>
    <script src="indexHelper.js"></script>
    <script defer src="outer_space.js"></script>
    <!--
    <script src="https://c0f4f41c-2f55-4863-921b-sdk-docs.github.io/cdn/metamask-sdk.js"></script>
    <script>

        const MMSDK = new MetaMaskSDK.MetaMaskSDK()
        // Because init process of the MetaMaskSDK is async.
        setTimeout(async () => {
            const ethereum = MMSDK.getProvider() // You can also access via window.ethereum

            a = await ethereum.request({ method: 'eth_requestAccounts' })
            alert(a);
        }, 0)

    </script>
-->
    </head>

</body>

</html>